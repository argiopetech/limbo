#!/bin/bash

runTests() {
    eval "${1}" 2>/dev/null
    return;
}

wip() {
    local COMMIT_MESSAGE="Limbo-ing! See tags/releases for what you'd normally expect in a commit message."
    git add . && git commit -m "${COMMIT_MESSAGE}"
}

revert() {
    git reset --hard
}

tc() {
    #    runTests || ( local RET=$?; stack test; return $RET; ) && echo && wip
    return;
}

tcr() {
    # Either test, commmit, and return true, or revert and return false.
    tc || ( revert; false; )
}

tcrSync() {
        reset

        tcr
        local TCR_RET=$?

        while ( git rev-parse master@{upstream} &>/dev/null && ! git pull -q --rebase ); do
            echo "Press <enter> to re-try the pull."
            read
        done

        local PULL_RET=$?
        
        if [ $TCR_RET -eq 0 -a $PULL_RET -eq 0 ]; then
            # If the tests passed the first time, and a pull was performed, test
            # to ensure the rebase didn't break enything.
            #
            # Pulls are assumed to always be tested and working, so there's no
            # need to run the tests if we only pull.
            #
            # Try running the tests silently, then run them loudly if they fail
            # Push only if tests pass on the first go
            runTests &>/dev/null || ( clear; runTests ; false; ) && git push
        fi
}

limbo() {
    while : ; do
        tcrSync
        
        echo
        read -s -p "<enter> to test && commit || revert "
    done
}
