#!/bin/bash

runTests() {
    eval "${1}" 2>/dev/null
    return;
}

wip() {
    local COMMIT_MESSAGE="Limbo-ing! See tags/releases for what you'd normally expect in a commit message."
    git add . && git commit -m "${COMMIT_MESSAGE}"
}

revert() {
    git reset --hard
}

tc() {
    #    runTests || ( local RET=$?; stack test; return $RET; ) && echo && wip
    return;
}

tcr() {
    # Either test, commmit, and return true, or revert and return false.
    tc || ( revert; false; )
}

tcrSync() {
        reset

        tcr
        local TCR_RET=$?

        # Update the remote. This works even if there is no remote.
        git remote update
        local REACHED_UPSTREAM=$?
        
        # Try to find the upstream remote hash
        #
        # If an upstream exists, this prints the hash and returns true.
        # If no upstream exists, this errors to /dev/null and returns false.
        local REMOTE_REV=$(git rev-parse @{upstream} 2>/dev/null)
        local HAS_UPSTREAM=$?

        local LOCAL_REV=$(git rev-parse @)

        
        [ -n "$REMOTE_REV" -a "$LOCAL_REV" != "$REMOTE_REV" ]
        local NEEDS_PULL=$?
        
        while ( [ $NEEDS_PULL -eq 0 ] && ! git pull -q --rebase --ff-only ); do
            read -p "Press <enter> to re-try the pull." REPLY
        done

        if [ $TCR_RET -eq 0 -a $NEEDS_PULL -eq 0 ]; then
            # If the tests passed the first time, and a push can be performed, test to ensure the
            # rebase didn't break enything.
            #
            # Pulls are assumed to always be tested and working, so there's no need to run the tests
            # if we only pull.
            #
            # Try running the tests silently, then run them loudly if they fail.
            runTests &>/dev/null || ( clear; runTests ; false; ) && git push
        fi
}

limbo() {
    while : ; do
        tcrSync
        
        echo
        read -s -p "<enter> to test && commit || revert "
    done
}
